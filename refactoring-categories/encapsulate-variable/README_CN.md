# 封装变量重构示例

本项目展示了使用Rust的**封装变量**重构技术，演示了封装可变全局状态的不同方法。

## 概述

重构展示了如何将公开暴露的可变全局变量转换为通过函数进行受控访问的适当封装变量。

## 文件结构

- `s00_before_encapsulation.rs` - 原始代码，直接访问全局变量
- `s01_after_encapsulation.rs` - 基础封装，使用getter/setter函数
- `s02_1_find_modify.rs` - 克隆封装的前置步骤：识别和重构修改逻辑
- `s02_2_clone_encapsulation.rs` - 克隆封装，显式复制
- `s03_set_clone_encapsulation.rs` - Setter接收副本以确保安全
- `main.rs` - 主入口点，运行所有示例

## 重构步骤

### 步骤0：封装前

- 全局可变状态直接暴露
- 任何代码都可以无控制地读取/修改
- 没有单一控制点来维护不变性

### 步骤1：基础封装

- 将全局变量设为私有
- 提供getter和setter函数
- 控制对变量引用的访问

### 步骤2：高级封装

- **2.1**: 识别和重构修改逻辑
- **2.2**: 克隆封装 - 返回数据副本
- 防止修改影响共享状态

### 步骤3：Setter接收副本

- Setter函数接收数据副本
- 防止源数据修改问题
- 展示Rust所有权优势

## 关键概念

### Rust特有优势

- **所有权系统**: 天然防止共享突变
- **移动语义**: Setter天然接收副本
- **借用检查器**: 防止许多常见错误
- **克隆特性**: 需要时显式复制

### 封装的好处

- **控制**: 单一访问控制点
- **安全**: 防止意外修改
- **可维护性**: 更容易更改实现
- **调试**: 更清晰的数据流

## 运行示例

```bash
cd refactoring-categories/encapsulate-variable
cargo run
```

每个示例将展示封装方法并打印结果。

## 测试

```bash
cargo test
```

测试验证每个封装方法产生预期的输出。

## 与其他语言比较

### Java/JavaScript问题

- 需要显式克隆以防止源数据修改
- 共享引用可能导致意外副作用
- 由于共享状态突变，调试更复杂

### Rust优势

- 所有权系统天然防止许多问题
- 移动语义使复制显式化
- 编译时安全性减少运行时错误
- 借用和所有权之间有清晰分离

## 进一步阅读

- 《重构：改善既有代码的设计》作者：Martin Fowler
- Rust书籍：所有权和借用章节
- Rust示例：所有权和引用

---

*这是"通过Rust学习重构"系列的一部分。*
